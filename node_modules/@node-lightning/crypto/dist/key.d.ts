/// <reference types="node" />
/**
 * Returns true when the Buffer represents a 256-bit number that is between
 * 0x1 and 0xffffffffffffffffffffffffffffffffbaaedce6af48a03bbfd25e8cd0364140
 * as documented in https://en.bitcoin.it/wiki/Private_key
 *
 * @param privKey 32-byte/256-bit buffer
 */
export declare function validPrivateKey(privKey: Buffer): boolean;
/**
 * Returns true when the Buffer represents a valid SEC encoded public
 * key stored in a buffer. This expects the prefix and length to be
 * correct.
 * @param pubkey
 */
export declare function validPublicKey(pubkey: Buffer): boolean;
/**
 * Generates a cryptographially secure 256-bit private key
 * that is valid for elliptic curve secp256k1
 *
 * @remarks This method uses crypto.randomBytes to
 * generate the random value. It may be better to use a
 * HRBG
 *
 * @returns the 32-byte/256-bit private key
 */
export declare function createPrivateKey(): Buffer;
/**
 * Gets the public key in the ellitic curve secp256k1
 * from the provided private key
 *
 * @param privKey 32-byte/256-bit private key
 * @returns 33-byte buffer for compressed,
 * 65-byte buffer for uncompressed
 */
export declare function getPublicKey(privKey: Buffer, compressed?: boolean): Buffer;
/**
 * Converts a public key between compressed and uncompressed format. If
 * the for
 * @param pubkey 33- or 65-byte buffer
 * @param compressed true when it should return 33-byte compressed public key
 * @returns
 */
export declare function convertPublicKey(pubkey: Buffer, compressed?: boolean): Buffer;
