"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAesKey = exports.aesDecrypt = exports.aesEncrypt = void 0;
const crypto_1 = __importDefault(require("crypto"));
/**
 * Encrypts data using AES
 * @param key symmetric key
 * @param buffer plaintext to encrypt
 */
function aesEncrypt({ key, buffer }) {
    const cipher = crypto_1.default.createCipher("aes256", key);
    let result = cipher.update(buffer);
    result = Buffer.concat([result, cipher.final()]);
    return result;
}
exports.aesEncrypt = aesEncrypt;
/**
 * Decrypts data using AES.
 * @param key symmetric key
 * @param buffer ciphertext to decrypt
 */
function aesDecrypt({ key, buffer }) {
    const decipher = crypto_1.default.createDecipher("aes256", key);
    let result = decipher.update(buffer);
    result = Buffer.concat([result, decipher.final()]);
    return result;
}
exports.aesDecrypt = aesDecrypt;
/**
 * Generate a a secure key from the passphrase and salt
 * by performing PBKDF2. If no salt is provided one is
 * generated via randomBytes.
 *
 * @param passphrase
 * @param [salt] 16-byte buffer or more
 */
function createAesKey({ passphrase, salt }) {
    if (!salt) {
        salt = crypto_1.default.randomBytes(16);
    }
    const key = crypto_1.default.pbkdf2Sync(passphrase, salt, 100000, 128, "sha512");
    return {
        key,
        salt,
    };
}
exports.createAesKey = createAesKey;
//# sourceMappingURL=aes.js.map