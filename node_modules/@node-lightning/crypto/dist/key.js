"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertPublicKey = exports.getPublicKey = exports.createPrivateKey = exports.validPublicKey = exports.validPrivateKey = void 0;
const crypto_1 = __importDefault(require("crypto"));
const secp256k1_1 = __importDefault(require("@node-lightning/secp256k1"));
// const minPrivateKey = BigInt("0x01");
// const maxPrivateKey = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140");
/**
 * Returns true when the Buffer represents a 256-bit number that is between
 * 0x1 and 0xffffffffffffffffffffffffffffffffbaaedce6af48a03bbfd25e8cd0364140
 * as documented in https://en.bitcoin.it/wiki/Private_key
 *
 * @param privKey 32-byte/256-bit buffer
 */
function validPrivateKey(privKey) {
    try {
        return secp256k1_1.default.privateKeyVerify(privKey);
    }
    catch (ex) {
        return false;
    }
}
exports.validPrivateKey = validPrivateKey;
/**
 * Returns true when the Buffer represents a valid SEC encoded public
 * key stored in a buffer. This expects the prefix and length to be
 * correct.
 * @param pubkey
 */
function validPublicKey(pubkey) {
    try {
        return secp256k1_1.default.publicKeyVerify(pubkey);
    }
    catch (ex) {
        return false;
    }
}
exports.validPublicKey = validPublicKey;
/**
 * Generates a cryptographially secure 256-bit private key
 * that is valid for elliptic curve secp256k1
 *
 * @remarks This method uses crypto.randomBytes to
 * generate the random value. It may be better to use a
 * HRBG
 *
 * @returns the 32-byte/256-bit private key
 */
function createPrivateKey() {
    let result;
    do {
        result = crypto_1.default.randomBytes(32);
    } while (!validPrivateKey(result));
    return result;
}
exports.createPrivateKey = createPrivateKey;
/**
 * Gets the public key in the ellitic curve secp256k1
 * from the provided private key
 *
 * @param privKey 32-byte/256-bit private key
 * @returns 33-byte buffer for compressed,
 * 65-byte buffer for uncompressed
 */
function getPublicKey(privKey, compressed = true) {
    return Buffer.from(secp256k1_1.default.publicKeyCreate(privKey, compressed));
}
exports.getPublicKey = getPublicKey;
/**
 * Converts a public key between compressed and uncompressed format. If
 * the for
 * @param pubkey 33- or 65-byte buffer
 * @param compressed true when it should return 33-byte compressed public key
 * @returns
 */
function convertPublicKey(pubkey, compressed = true) {
    return Buffer.from(secp256k1_1.default.publicKeyConvert(pubkey, compressed));
}
exports.convertPublicKey = convertPublicKey;
//# sourceMappingURL=key.js.map