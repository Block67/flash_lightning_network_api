"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.recoverPubKey = exports.isDERSig = exports.verifySig = exports.sigToDER = exports.signWithRecovery = exports.sign = exports.privateKeyMul = exports.ecdh = void 0;
const secp256k1_1 = __importDefault(require("@node-lightning/secp256k1"));
/**
 * Elliptic Curve Diffie-Helman on secp256k1 takes a
 * public key and point multiplies it by the private key.
 * The resulting compressed public key value is hashed via
 * sha256.
 *
 * @param publicKey 33-byte compressed public key
 * @param privateKey  32-byte private key
 * @returns 32-byte sha256 of the point multiple
 */
function ecdh(publicKey, privateKey) {
    return Buffer.from(secp256k1_1.default.ecdh(publicKey, privateKey));
}
exports.ecdh = ecdh;
/**
 * Performs modular multiplication on the secret value by multiplying by the
 * tweak value
 * @param secret 32-byte secret
 * @param tweak 32-byte tweak
 * @returns 32-byte secret
 */
function privateKeyMul(secret, tweak) {
    return Buffer.from(secp256k1_1.default.privateKeyTweakMul(Buffer.from(secret), tweak));
}
exports.privateKeyMul = privateKeyMul;
/**
 * Create an ECDSA signature for the 32-byte message using the private
 * key. This method returns the normalized low-s version of the signature
 * as a 64-byte Buffer (r,s) values.
 * @param msg 32-byte message
 * @param privateKey 32-byte secp256k1 private key
 * @returns signatures as 64-byte buffer with (r,s) pair
 */
function sign(msg, privateKey) {
    const { signature } = secp256k1_1.default.ecdsaSign(msg, privateKey);
    secp256k1_1.default.signatureNormalize(signature);
    return Buffer.from(signature);
}
exports.sign = sign;
/**
 * Create an ECDSA signature for the 32-byte message using the private
 * key. This method returns both the signature in the normalized low-s
 * version of the signature as a 64-bte Buffer (r,s) and the recovery
 * identifier.
 * @param msg 32-byte message
 * @param privateKey 32-byte secp256k1 private key
 */
function signWithRecovery(msg, privateKey) {
    const { signature, recid } = secp256k1_1.default.ecdsaSign(msg, privateKey);
    return {
        signature: Buffer.from(signature),
        recovery: recid,
    };
}
exports.signWithRecovery = signWithRecovery;
/**
 * Encodes a signature into a DER encoding. This encoding is 8-73 bytes
 * in length depending on the length of the s value in the signature.
 * @param sig 64-byte buffer containing (r, s)
 */
function sigToDER(sig) {
    return Buffer.from(secp256k1_1.default.signatureExport(sig));
}
exports.sigToDER = sigToDER;
/**
 * Verifies an ECDSA signature and returns true or false
 * if the signatures is valid.
 *
 * @param msg 32-byte message (256 hash or message)
 * @param sig 64-byte
 * @param pubkey 33-byte compressed pubkey
 * @returns true when signature is valid
 */
function verifySig(msg, sig, pubkey) {
    return secp256k1_1.default.ecdsaVerify(sig, msg, pubkey);
}
exports.verifySig = verifySig;
/**
 * Returns true if the signature is a DER encoded signature
 * @param sig a DER encoded signature
 */
function isDERSig(sig) {
    try {
        secp256k1_1.default.signatureImport(sig);
        return true;
    }
    catch (ex) {
        return false;
    }
}
exports.isDERSig = isDERSig;
/**
 * Recovers the public key from the signature and recovery identifier
 * for the signed message.
 * @param signature 64-byte signature
 * @param recovery recovery id
 * @param message message that was signed
 * @param compressed whether the pubkey is compressed
 */
function recoverPubKey(signature, recovery, message, compressed = true) {
    const result = secp256k1_1.default.ecdsaRecover(signature, recovery, message, compressed);
    return Buffer.from(result);
}
exports.recoverPubKey = recoverPubKey;
/**
 * Tweaks a public key by adding tweak * G to the point. The equation is
 * T = P + t*G
 *
 * @param publicKey 33-byte or 65-byte public key
 * @param tweak 32-byte scalar value that is multiplied by G
 * @param compressed true to compress the resulting point
 * @returns the 33-byte compressed or 65-byte uncompressed public key point
 */
function publicKeyTweakAdd(publicKey, tweak, compressed = true) {
    return Buffer.from(secp256k1_1.default.publicKeyTweakAdd(publicKey, tweak, compressed));
}
exports.publicKeyTweakAdd = publicKeyTweakAdd;
/**
 * Tweaks a public key by multiplying it against a scalar. The equation is
 * T = P * t
 *
 * @param publicKey 33-byte or 65-byte public key
 * @param tweak 32-byte tweak to multiply against the public key
 * @param compressed true to compress the resulting point
 * @returns the 33-byte compressed or 65-byte uncompressed public key point
 */
function publicKeyTweakMul(publicKey, tweak, compressed = true) {
    return Buffer.from(secp256k1_1.default.publicKeyTweakMul(publicKey, tweak, compressed));
}
exports.publicKeyTweakMul = publicKeyTweakMul;
/**
 * Performs point addition
 *
 * @param pubkeys list of 33-byte or 65-byte public keys
 * @param compressed true to compress the resulting point
 * @returns the 33-byte compressed or 65-byte uncompressed public key point
 */
function publicKeyCombine(pubkeys, compressed = true) {
    return Buffer.from(secp256k1_1.default.publicKeyCombine(pubkeys, compressed));
}
exports.publicKeyCombine = publicKeyCombine;
/**
 * Tweaks a private key by adding a value to it. The question is: e + t.
 *
 * @param privateKey the 32-byte private key
 * @param tweak a 32-byte tweak
 */
function privateKeyTweakAdd(privateKey, tweak) {
    return Buffer.from(secp256k1_1.default.privateKeyTweakAdd(Buffer.from(privateKey), tweak));
}
exports.privateKeyTweakAdd = privateKeyTweakAdd;
/**
 * Tweaks a private key by multiplying it. The equation is: e * t.
 *
 * @param privateKey the 32-byte private key
 * @param tweak a 32-byte tweak
 */
function privateKeyTweakMul(privateKey, tweak) {
    return Buffer.from(secp256k1_1.default.privateKeyTweakMul(Buffer.from(privateKey), tweak));
}
exports.privateKeyTweakMul = privateKeyTweakMul;
//# sourceMappingURL=secp256k1.js.map