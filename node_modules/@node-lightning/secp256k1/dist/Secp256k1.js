"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Secp256k1 = void 0;
const Secp256k1Error_1 = require("./Secp256k1Error");
const Utils_1 = require("./Utils");
class Secp256k1 {
    constructor(binding) {
        this.binding = binding;
    }
    contextRandomize(seed) {
        Utils_1.assert(seed === null || seed instanceof Uint8Array, "Expected seed to be an Uint8Array or null");
        if (seed !== null)
            Utils_1.isUint8Array("seed", seed, 32);
        switch (this.binding.contextRandomize(seed)) {
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.CONTEXT_RANDOMIZE_UNKNOW);
        }
    }
    privateKeyVerify(seckey) {
        if (!(seckey instanceof Uint8Array)) {
            return false;
        }
        if (seckey.length && seckey.length !== 32) {
            return false;
        }
        return this.binding.privateKeyVerify(seckey) === 0;
    }
    privateKeyNegate(seckey) {
        Utils_1.isUint8Array("private key", seckey, 32);
        switch (this.binding.privateKeyNegate(seckey)) {
            case 0:
                return seckey;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.IMPOSSIBLE_CASE);
        }
    }
    privateKeyTweakAdd(seckey, tweak) {
        Utils_1.isUint8Array("private key", seckey, 32);
        Utils_1.isUint8Array("tweak", tweak, 32);
        const output = new Uint8Array(seckey);
        switch (this.binding.privateKeyTweakAdd(output, tweak)) {
            case 0:
                return output;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.TWEAK_ADD);
        }
    }
    privateKeyTweakMul(seckey, tweak) {
        Utils_1.isUint8Array("private key", seckey, 32);
        Utils_1.isUint8Array("tweak", tweak, 32);
        const output = new Uint8Array(seckey);
        switch (this.binding.privateKeyTweakMul(output, tweak)) {
            case 0:
                return output;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.TWEAK_MUL);
        }
    }
    publicKeyVerify(pubkey) {
        if (!(pubkey instanceof Uint8Array)) {
            return false;
        }
        if (pubkey.length && pubkey.length !== 33 && pubkey.length !== 65) {
            return false;
        }
        return this.binding.publicKeyVerify(pubkey) === 0;
    }
    publicKeyCreate(seckey, compressed = true, output) {
        Utils_1.isUint8Array("private key", seckey, 32);
        Utils_1.isCompressed(compressed);
        output = Utils_1.assertOutput(output, compressed ? 33 : 65);
        switch (this.binding.publicKeyCreate(output, seckey)) {
            case 0:
                return output;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.SECKEY_INVALID);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_SERIALIZE);
        }
    }
    publicKeyConvert(pubkey, compressed = true, output) {
        Utils_1.isUint8Array("public key", pubkey, [33, 65]);
        Utils_1.isCompressed(compressed);
        output = Utils_1.assertOutput(output, compressed ? 33 : 65);
        switch (this.binding.publicKeyConvert(output, pubkey)) {
            case 0:
                return output;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_PARSE);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_SERIALIZE);
        }
    }
    publicKeyNegate(pubkey, compressed = true, output) {
        Utils_1.isUint8Array("public key", pubkey, [33, 65]);
        Utils_1.isCompressed(compressed);
        output = Utils_1.assertOutput(output, compressed ? 33 : 65);
        switch (this.binding.publicKeyNegate(output, pubkey)) {
            case 0:
                return output;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_PARSE);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.IMPOSSIBLE_CASE);
            case 3:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_SERIALIZE);
        }
    }
    publicKeyCombine(pubkeys, compressed = true, output) {
        Utils_1.assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
        Utils_1.assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
        for (const pubkey of pubkeys) {
            Utils_1.isUint8Array("public key", pubkey, [33, 65]);
        }
        Utils_1.isCompressed(compressed);
        output = Utils_1.assertOutput(output, compressed ? 33 : 65);
        switch (this.binding.publicKeyCombine(output, pubkeys)) {
            case 0:
                return output;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_PARSE);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_COMBINE);
            case 3:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_SERIALIZE);
        }
    }
    publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
        Utils_1.isUint8Array("public key", pubkey, [33, 65]);
        Utils_1.isUint8Array("tweak", tweak, 32);
        Utils_1.isCompressed(compressed);
        output = Utils_1.assertOutput(output, compressed ? 33 : 65);
        switch (this.binding.publicKeyTweakAdd(output, pubkey, tweak)) {
            case 0:
                return output;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_PARSE);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.TWEAK_ADD);
        }
    }
    publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
        Utils_1.isUint8Array("public key", pubkey, [33, 65]);
        Utils_1.isUint8Array("tweak", tweak, 32);
        Utils_1.isCompressed(compressed);
        output = Utils_1.assertOutput(output, compressed ? 33 : 65);
        switch (this.binding.publicKeyTweakMul(output, pubkey, tweak)) {
            case 0:
                return output;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_PARSE);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.TWEAK_MUL);
        }
    }
    signatureNormalize(sig) {
        Utils_1.isUint8Array("signature", sig, 64);
        switch (this.binding.signatureNormalize(sig)) {
            case 0:
                return sig;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.SIG_PARSE);
        }
    }
    signatureExport(sig, output) {
        Utils_1.isUint8Array("signature", sig, 64);
        output = Utils_1.assertOutput(output, 72);
        const obj = { output, outputlen: 72 };
        switch (this.binding.signatureExport(obj, sig)) {
            case 0:
                return output.slice(0, obj.outputlen);
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.SIG_PARSE);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.IMPOSSIBLE_CASE);
        }
    }
    signatureImport(sig, output) {
        Utils_1.isUint8Array("signature", sig);
        output = Utils_1.assertOutput(output, 64);
        switch (this.binding.signatureImport(output, sig)) {
            case 0:
                return output;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.SIG_PARSE);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.IMPOSSIBLE_CASE);
        }
    }
    ecdsaSign(msg32, seckey, options = {}, output) {
        Utils_1.isUint8Array("message", msg32, 32);
        Utils_1.isUint8Array("private key", seckey, 32);
        Utils_1.assert(Utils_1.toTypeString(options) === "Object", "Expected options to be an Object");
        if (options.data !== undefined)
            Utils_1.isUint8Array("options.data", options.data);
        if (options.noncefn !== undefined)
            Utils_1.assert(Utils_1.toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
        output = Utils_1.assertOutput(output, 64);
        const obj = { signature: output, recid: null };
        switch (this.binding.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
            case 0:
                return obj;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.SIGN);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.IMPOSSIBLE_CASE);
        }
    }
    ecdsaVerify(sig, msg32, pubkey) {
        Utils_1.isUint8Array("signature", sig, 64);
        Utils_1.isUint8Array("message", msg32, 32);
        Utils_1.isUint8Array("public key", pubkey, [33, 65]);
        switch (this.binding.ecdsaVerify(sig, msg32, pubkey)) {
            case 0:
                return true;
            case 3:
                return false;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.SIG_PARSE);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_PARSE);
        }
    }
    ecdsaRecover(sig, recid, msg32, compressed = true, output) {
        Utils_1.isUint8Array("signature", sig, 64);
        Utils_1.assert(Utils_1.toTypeString(recid) === "Number" && recid >= 0 && recid <= 3, "Expected recovery id to be a Number within interval [0, 3]");
        Utils_1.isUint8Array("message", msg32, 32);
        Utils_1.isCompressed(compressed);
        output = Utils_1.assertOutput(output, compressed ? 33 : 65);
        switch (this.binding.ecdsaRecover(output, sig, recid, msg32)) {
            case 0:
                return output;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.SIG_PARSE);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.RECOVER);
            case 3:
                throw new Error(Secp256k1Error_1.Secp256k1Error.IMPOSSIBLE_CASE);
        }
    }
    ecdh(pubkey, seckey, options = {}, output) {
        Utils_1.isUint8Array("public key", pubkey, [33, 65]);
        Utils_1.isUint8Array("private key", seckey, 32);
        Utils_1.assert(Utils_1.toTypeString(options) === "Object", "Expected options to be an Object");
        if (options.data !== undefined)
            Utils_1.isUint8Array("options.data", options.data);
        if (options.hashfn !== undefined) {
            Utils_1.assert(Utils_1.toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
            if (options.xbuf !== undefined)
                Utils_1.isUint8Array("options.xbuf", options.xbuf, 32);
            if (options.ybuf !== undefined)
                Utils_1.isUint8Array("options.ybuf", options.ybuf, 32);
        }
        output = Utils_1.assertOutput(output, 32);
        switch (this.binding.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
            case 0:
                return output;
            case 1:
                throw new Error(Secp256k1Error_1.Secp256k1Error.PUBKEY_PARSE);
            case 2:
                throw new Error(Secp256k1Error_1.Secp256k1Error.ECDH);
        }
    }
}
exports.Secp256k1 = Secp256k1;
//# sourceMappingURL=Secp256k1.js.map