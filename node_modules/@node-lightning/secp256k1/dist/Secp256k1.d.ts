import { EcdhOptions } from "./EcdhOptions";
import { EcdsaOptions } from "./EcdsaOptions";
import { EcdsaResult } from "./EcdsaResult";
export declare class Secp256k1 {
    readonly binding: any;
    constructor(binding: any);
    contextRandomize(seed: Uint8Array): void;
    privateKeyVerify(seckey: Uint8Array): boolean;
    privateKeyNegate(seckey: Uint8Array): Uint8Array;
    privateKeyTweakAdd(seckey: Uint8Array, tweak: Uint8Array): Uint8Array;
    privateKeyTweakMul(seckey: Uint8Array, tweak: Uint8Array): Uint8Array;
    publicKeyVerify(pubkey: Uint8Array): boolean;
    publicKeyCreate(seckey: Uint8Array, compressed?: boolean, output?: Uint8Array): Uint8Array;
    publicKeyConvert(pubkey: Uint8Array, compressed?: boolean, output?: Uint8Array): Uint8Array;
    publicKeyNegate(pubkey: Uint8Array, compressed?: boolean, output?: Uint8Array): Uint8Array;
    publicKeyCombine(pubkeys: Uint8Array[], compressed?: boolean, output?: Uint8Array): Uint8Array;
    publicKeyTweakAdd(pubkey: Uint8Array, tweak: Uint8Array, compressed?: boolean, output?: Uint8Array): Uint8Array;
    publicKeyTweakMul(pubkey: Uint8Array, tweak: Uint8Array, compressed?: boolean, output?: Uint8Array): Uint8Array;
    signatureNormalize(sig: Uint8Array): Uint8Array;
    signatureExport(sig: Uint8Array, output?: Uint8Array): Uint8Array;
    signatureImport(sig: Uint8Array, output?: Uint8Array): Uint8Array;
    ecdsaSign(msg32: Uint8Array, seckey: Uint8Array, options?: EcdsaOptions, output?: Uint8Array): EcdsaResult;
    ecdsaVerify(sig: Uint8Array, msg32: Uint8Array, pubkey: Uint8Array): boolean;
    ecdsaRecover(sig: Uint8Array, recid: number, msg32: Uint8Array, compressed?: boolean, output?: Uint8Array): Uint8Array;
    ecdh(pubkey: Uint8Array, seckey: Uint8Array, options?: EcdhOptions, output?: Uint8Array): Uint8Array;
}
