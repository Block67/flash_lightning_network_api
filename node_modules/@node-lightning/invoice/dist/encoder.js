"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = void 0;
const bech32_1 = __importDefault(require("bech32"));
const bech32Util = __importStar(require("./bech32-util"));
const crypto = __importStar(require("./crypto"));
const encode_pico_1 = require("./encode-pico");
const field_type_1 = require("./field-type");
const word_cursor_1 = require("./word-cursor");
/**
 * Encodes an invoice object into the bech32 invoice and digitally
 * signs the invoice using ECDSA.
 * @param invoice
 * @param privKey 33-byte secp256k1 private key
 * @returns {string} bech32 encoded invoice
 */
function encode(invoice, privKey) {
    const writer = new word_cursor_1.WordCursor();
    const encodedAmount = encode_pico_1.encodePico(invoice._value ? invoice._value.toString() : null) || "";
    const prefix = `ln${invoice.network}${encodedAmount}`;
    writer.writeUIntBE(invoice.timestamp, 7);
    _encodeData(invoice, writer);
    // generate sig data
    const bytes = bech32Util.convertWords(writer.words, 5, 8, true);
    const sigData = Buffer.concat([Buffer.from(prefix, "utf8"), Buffer.from(bytes)]);
    // generate sig hash
    const sigHash = crypto.sha256(sigData);
    // sign
    const { signature, recovery } = crypto.ecdsaSign(sigHash, privKey);
    writer.writeBytes(signature);
    writer.writeUIntBE(recovery, 1);
    // finally encode the invoice in bech32 and allow
    // an invoice to be any length
    return bech32_1.default.encode(prefix, writer.words, Number.MAX_SAFE_INTEGER);
}
exports.encode = encode;
function _encodeData(invoice, writer) {
    for (const datum of invoice.fields) {
        switch (datum.type) {
            case field_type_1.FIELD_TYPE.PAYMENT_HASH:
                {
                    // should be 52, but allow for creation of variable length
                    // values so we can construct non-valid invoices for testing
                    const dataLen = bech32Util.sizeofBytes(datum.value.byteLength);
                    writer.writeUIntBE(datum.type, 1);
                    writer.writeUIntBE(dataLen, 2);
                    writer.writeBytes(datum.value);
                }
                break;
            case field_type_1.FIELD_TYPE.ROUTE:
                {
                    const bits = datum.value.length * (264 + 64 + 32 + 32 + 16);
                    writer.writeUIntBE(datum.type, 1);
                    const dataLen = bech32Util.sizeofBits(bits);
                    writer.writeUIntBE(dataLen, 2);
                    const buffer = Buffer.alloc(bits / 8);
                    let position = 0;
                    for (const route of datum.value) {
                        route.pubkey.copy(buffer, position);
                        position += 264 / 8;
                        route.short_channel_id.copy(buffer, position);
                        position += 64 / 8;
                        buffer.writeUInt32BE(route.fee_base_msat, position);
                        position += 32 / 8;
                        buffer.writeUInt32BE(route.fee_proportional_millionths, position);
                        position += 32 / 8;
                        buffer.writeUInt16BE(route.cltv_expiry_delta, position);
                        position += 16 / 8;
                    }
                    writer.writeBytes(buffer);
                }
                break;
            case field_type_1.FIELD_TYPE.EXPIRY:
                {
                    const dataLen = bech32Util.sizeofNum(datum.value);
                    writer.writeUIntBE(datum.type, 1);
                    writer.writeUIntBE(dataLen, 2);
                    writer.writeUIntBE(datum.value, dataLen);
                }
                break;
            case field_type_1.FIELD_TYPE.FALLBACK_ADDRESS:
                {
                    const dataLen = bech32Util.sizeofBytes(datum.value.address.byteLength) + 1;
                    writer.writeUIntBE(datum.type, 1);
                    writer.writeUIntBE(dataLen, 2);
                    writer.writeUIntBE(datum.value.version, 1);
                    writer.writeBytes(datum.value.address);
                }
                break;
            case field_type_1.FIELD_TYPE.SHORT_DESC:
                {
                    const buf = Buffer.from(datum.value, "utf8");
                    const dataLen = bech32Util.sizeofBytes(buf.byteLength);
                    writer.writeUIntBE(datum.type, 1);
                    writer.writeUIntBE(dataLen, 2);
                    writer.writeBytes(buf);
                }
                break;
            case field_type_1.FIELD_TYPE.PAYEE_NODE:
                {
                    // should be 53, but allow for creation of variable length
                    // values so we can construct non-valid invoices for testing
                    const dataLen = bech32Util.sizeofBytes(datum.value.byteLength);
                    writer.writeUIntBE(datum.type, 1);
                    writer.writeUIntBE(dataLen, 2);
                    writer.writeBytes(datum.value);
                }
                break;
            case field_type_1.FIELD_TYPE.HASH_DESC:
                {
                    const dataLen = bech32Util.sizeofBytes(datum.value.byteLength);
                    writer.writeUIntBE(datum.type, 1);
                    writer.writeUIntBE(dataLen, 2);
                    writer.writeBytes(datum.value);
                }
                break;
            case field_type_1.FIELD_TYPE.MIN_FINAL_CLTV_EXPIRY:
                {
                    const dataLen = bech32Util.sizeofNum(datum.value);
                    writer.writeUIntBE(datum.type, 1);
                    writer.writeUIntBE(dataLen, 2);
                    writer.writeUIntBE(datum.value, dataLen);
                }
                break;
            default: {
                if (!(datum.value instanceof Buffer)) {
                    throw new Error("Cannot process unknown field");
                }
                const dataLen = bech32Util.sizeofBytes(datum.value.byteLength);
                writer.writeUIntBE(datum.type, 1);
                writer.writeUIntBE(dataLen, 2);
                writer.writeBytes(datum.value);
            }
        }
    }
}
//# sourceMappingURL=encoder.js.map