/// <reference types="node" />
import { FallbackAddress } from "./fallback-address";
import { Route } from "./route";
import { Signature } from "./signature";
/**
 * Invoice is the state container used for invoice data. It is used
 * when building an invoice or contains the results from decoded
 * invoices. The Invoice type does not perform validation on
 * data it contains but does contain helper methods to help
 * construct proper invoices.
 */
export declare class Invoice {
    network: string;
    timestamp: number;
    fields: any[];
    unknownFields: any[];
    /**
     * ECDSA signature used to sign the invoice.
     */
    signature: Signature;
    /**
     * Compressed public key on elliptic curve secp256k1 corresponding
     * to the node that generated and signed the invoice. Returned
     * as 33-bytes.
     */
    pubkey: Buffer;
    /**
     * Buffer containing the buffer of the data used to generate the
     * hash used in the signature.
     */
    hashData: Buffer;
    /**
     * Inidicates if signature recovery was used when decoding and
     * performing signature verification for an invoice. This value
     * will be false if a payee node field was provided.
     */
    usedSigRecovery: boolean;
    /**
     * Invoice value stored in pico bitcoin
     */
    _value: bigint;
    /**
     * Returns true when the invoice has a value
     * associated with it. Invoices may optionally contain a value.
     * When there is no value, the invoice is for the receipt of
     * any value.
     */
    get hasValue(): boolean;
    /**
     * Warning: there is the possibility of precision loss!
     *
     * Gets the value in bitcoin as a string by converting from pico btc
     * into bitcoin. Returns null if the invoice has no amount.
     *
     * Sets the value from a number or string that represeents a bitcoin
     * value, such as 0.0001 to represent 10000 satoshi. Setting a falsy
     * value will remove the value from the invoice.
     *
     * @deprecated This property is maintained for backwards compaibility.
     * Use property `valueSat` or `valueMsat` instead.
     */
    get amount(): string;
    set amount(val: string);
    /**
     * Warning: Msat fractions are truncated!
     *
     * Gets the value in satoshi as a string by converting from pico btc
     * into satoshi. Returns null if the invoice has no amount.
     *
     * Sets the value in satoshi from a string or number, such as 10000 satoshi.
     * Setting a falsy value will remove the value from the invoice.
     */
    get valueSat(): string;
    set valueSat(val: string);
    /**
     * Gets the value in milli-sataoshi as a string or returns null
     * if the invoice has no amount.
     *
     * Sets the value in millisatoshi from a string or number. Setting a falsy
     * value will remove the value from the invoice.
     */
    get valueMsat(): string;
    set valueMsat(val: string);
    /**
     * Get the expiry time for the invoice as a big endian number
     * of seconds. The defualt is one hour (3600).
     *
     * Sets the expiry time in seconds for the invoice.  Only a single
     * expiry field is valid in the invoice.
     */
    get expiry(): number;
    set expiry(value: number);
    /**
     * Gets the 256-bit payment hash. The preimage of this value
     * will provide proof of payment.
     *
     * Sets the 256-bit payment hash for the invoice from a Buffer
     * or hex-encoded string. Only a single field of this type is
     * valid in the invoice.
     */
    get paymentHash(): Buffer;
    set paymentHash(value: Buffer);
    /**
     * Gets the description as either a shortDesc or hashDesc
     * value. If it is the former it is returned as a string.
     * hashDesc is returned as a buffer of the hash.
     *
     * Sets the description for the invoice. An invoice must use hash
     * description for messages longer than 639 bytes. If the string is
     * longer than 639 bytes, the description will be hashed and stored
     * in hashDesc. Otherwise, the raw string will be stored in the
     * short desc.
     */
    get desc(): string | Buffer;
    set desc(desc: string | Buffer);
    /**
     * Gets the short description text. Returns null when the invoice
     * does not contain a short description. An invoice must set
     * either a short description or a hash description.
     *
     * Sets the short description text. Maximum valid length is 639
     * bytes. Only a single short desc or hash desc field is allowed.
     * Setting this field will remove the hashDesc field value.
     */
    get shortDesc(): string;
    set shortDesc(value: string);
    /**
     * Gets the 256-bit hash of the description. Returns
     * null when an invoice does not contain a hash description.
     * An invoice must contain either a shortDesc or hashDesc.
     *
     * Sets the hash description to the hex-encoded string or
     * Buffer containing the the hashed description.
     * This must be used for descriptions that are over 639 bytes
     * long. Setting this field will remove any short desc fields.
     */
    get hashDesc(): Buffer;
    set hashDesc(value: Buffer);
    /**
     * Gets the 33-byte public key of the payee node. This is
     * used to explicitly describe the payee node instead of
     * relying on pub key recovery from the signature.
     *
     * Sets the 33-byte public key of the payee node. This is
     * used to set the public key explicitly instead of relying
     * on signature recovery. This field must match the pubkey
     * used to generate the signature.
     */
    get payeeNode(): Buffer;
    set payeeNode(value: Buffer);
    /**
     * Gets the min final route CLTV expiry. If none is provided,
     * the default is 9.
     *
     * Sets the min final route CLTV expiry used in the final route.
     */
    get minFinalCltvExpiry(): number;
    set minFinalCltvExpiry(value: number);
    /**
     * Gets a list of fall back addresses. An invoice can include
     * multiple fallback addresses to send to an on-chain address
     * in the event of failure.
     */
    get fallbackAddresses(): FallbackAddress[];
    /**
     * Adds a fallback address to the invoice. An invoice can include
     * one or more fallback addresses to send to an on-chain address
     * in the event of failure. This field may not make sense for small
     * or time-sensitive payments.
     *
     * The address string will be parsed and the appropriate address
     * type is added to the field metadata. The address will be
     * converted into a buffer containing the string values of the
     * address.
     */
    addFallbackAddress(addrStr: string): void;
    /**
     * Gets the list of routes that are specified in the invoice.
     * Route information is necessary to route payments to private
     * nodes.
     */
    get routes(): Route[];
    /**
     * Adds a collection of routes to the invoice. A route entry must
     * be provided by private nodes so that a public addressible node
     * can be found by the recipient.
     *
     * Multiple route fields can be added to an invoice in according
     * with BOLT 11 to give the routing options.
     */
    addRoute(routes: Route[]): void;
    /**
     * Gets the value of thee first matching field that matches the field
     * type. If no result is found, the default value will be used.
     */
    private _getFieldValue;
    /**
     * Sets the field value for the first matching field. If no
     * field exists it will insert a new field with the type and value
     * supplied.
     */
    private _setFieldValue;
    /**
     * Removes the fields that match the supplied type.
     */
    private _removeFieldByType;
}
