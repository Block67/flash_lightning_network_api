/// <reference types="node" />
/**
 * Utility class for writing arbitrary data into a Buffer. This class will
 * automatically expand the underlying Buffer and return a trimmed view
 * when complete.
 */
export declare class BufferWriter {
    private _position;
    private _fixed;
    private _buffer;
    /**
     * Constructs a BufferWriter that can optionally wrap an existing Buffer.
     * If no buffer is provided, the BufferWriter will internally manage an
     * exponentially growing Buffer to allow writing of data of an unknown size.
     *
     * If a Buffer is provided, writing that would overflow will throw an
     * exception.
     * @param buffer
     */
    constructor(buffer?: Buffer);
    /**
     * Gets the current size of the output Buffer
     */
    get size(): number;
    /**
     * Returns the Buffer which will be either the full Buffer if this was a
     * fixed Buffer or will be the expandable Buffer sliced to the current
     * position
     */
    toBuffer(): Buffer;
    /**
     * Returns the Buffer as a hex encoded string. This is functionally
     * a call to `toBuffer` followed by `toString("hex")`.
     * @returns
     */
    toHex(): string;
    /**
     * Write at the current positiion
     * @param val
     */
    writeUInt8(val: number): void;
    /**
     * Write at the current positiion
     * @param val
     */
    writeUInt16LE(val: number): void;
    /**
     * Write at the current positiion
     * @param val
     */
    writeUInt16BE(val: number): void;
    /**
     * Write at the current positiion
     * @param val
     */
    writeUInt32LE(val: number): void;
    /**
     * Write at the current positiion
     * @param val
     */
    writeUInt32BE(val: number): void;
    /**
     * Write at the current positiion
     * @param value
     */
    writeUInt64LE(value: number | bigint): void;
    /**
     * Write at the current positiion
     * @param value
     */
    writeUInt64BE(value: number | bigint): void;
    /**
     * Writes the number in the specified number of bytes.
     * @param val
     * @param bytes
     */
    writeUIntLE(val: number, len: number): void;
    /**
     * Writes the number in the specified number of bytes.
     * @param value
     * @param bytes
     */
    writeUIntBE(val: number, len: number): void;
    /**
     * Write bytes at the current positiion
     * @param buffer
     */
    writeBytes(buffer: Buffer): void;
    /**
     * Reads a variable length unsigned integer in little-endian as specified in
     * the Bitcoin protocol documentation.
     *
     * < 0xfd = 1 byte number
     *   0xfd = 2 byte number (3 bytes total)
     *   0xfe = 4 byte number (5 bytes total)
     *   0xff = 8 byte number (9 bytes total)
     */
    writeVarInt(val: bigint | number): void;
    /**
     * Reads a variable length unsigned integer as specified in the Lightning Network
     * protocol documentation and always returns a BigInt to maintain a consistent
     * call signature.
     *
     * @remarks
     * Specified in:
     * https://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#appendix-a-bigsize-test-vectors
     *
     * < 0xfd = 1 byte number
     *   0xfd = 2 byte number (3 bytes total)
     *   0xfe = 4 byte number (5 bytes total)
     *   0xff = 8 byte number (9 bytes total)
     */
    writeBigSize(val: bigint | number): void;
    /**
     * TLV 0 to 2 byte unsigned integer encoded in big-endian.
     * @param val
     */
    writeTUInt16(val: number): void;
    /**
     * TLV 0 to 4 byte unsigned integer encoded in big-endian.
     */
    writeTUInt32(val: number): void;
    /**
     * TLV 0 to 8 byte unsigned integer encoded in big-endian.
     */
    writeTUInt64(val: bigint): void;
    /**
     * Expands the underlying buffer as needed by doubling the size of the
     * Buffer when it needs to grow.
     * @param needed
     */
    private _expand;
    /**
     * Helper for writing to the buffer using built-in write
     * functions
     * @param fn name of function
     * @param val number to write
     * @param len length of number in bytes
     */
    private _writeStandard;
}
